-
  2.A.9. If the follow-up level requires sending an email and the field 'Skip Follow-Up Email Sending' is deactivated, 
         an email must be created with the content indicated in the follow-up level.
    2.A.9.a. It must be listed in Settings > Technical > Email > Emails.
    2.A.9.a.i. It must have type 'Email'.
    2.A.9.b. It must be visible from the one2many field ‘Follow-Up Mails’ of the account.invoice.
    2.A.9.c. It must be visible from the one2many field ‘Follow-Up Mails’ of the res.partner.
    2.A.9.f. It must be visible from the one2many field ‘Follow-Up Mails’ of the ancestors 
-
  !python {model: account.invoice}: |
    print 'Starting the test 2.A.9.'
    cr.execute("SAVEPOINT test;")

-
  2.A.9. Sets the system parameter with the location of webkit.
-
  !python {model: ir.config_parameter}: |
    from openerp import SUPERUSER_ID
    self.set_param(cr, SUPERUSER_ID, 'webkit_path', '/home/openerp/wkhtmltopdf-amd64', context)


-
  2.A.9. Defines a bank account for the company (this is needed for follow-ups)
-
  !record {model: res.partner.bank, id: res_partner_bank_2_A_9}:
    state: bank
    acc_number: 123
    partner_id: base.main_partner
    bank: base.res_bank_1
    bank_name: 'Test Bank'
    company_id: base.main_company

-
  2.A.9. Creates an invoice with one line.
-
  !record {model: account.invoice, id: account_invoice_2_A_9}:
    partner_id: base.res_partner_address_4
    journal_id: account.sales_journal
    account_id: account.a_recv
    date_due: !eval datetime.today().strftime("%Y-%m-%d")
    invoice_line:
      - product_id: product.product_product_48
        name: 'USB Adapter'
        quantity: 18.0
        uos_id: product.product_uom_unit
        price_unit: 5.0

-
  2.A.9. Gets the delay of the first follow-up level and sets the due date of the invoice to be greater (one more) than that delay.
         Makes sure that the follow-up level is going to send an email.
-
  !python {model: followup.level}: |
    from openerp import SUPERUSER_ID
    from datetime import datetime, timedelta
    # Gets the follow-up levels associated to the company of the admin.
    superuser_id = self.pool.get('res.users').search(cr, uid, [('id', '=', SUPERUSER_ID)], limit=1, context=context)[0]
    company_id = self.pool.get('res.company').search(cr, uid, [('id', '=', superuser_id)], limit=1, context=context)[0]
    followup_config_id = self.pool.get('followup.config').search(cr, uid, [('company_id', '=', company_id)], context=context)[0]
    followup_level_ids = self.pool.get('followup.level').search(cr, uid, [('followup_config_id', '=', followup_config_id)], context=context)

    # Stores the ID of the first follow-up level.
    context['first_followup_level'] = followup_level_ids[0]

    # Gets the delay of the first follow-up level (they are sorted).
    delay = self.pool.get('followup.level').browse(cr, uid, followup_level_ids[0], context=context).delay
    context['followup_level_delay'] = delay

    # Gets the invoice
    invoice_obj = self.pool.get('account.invoice').browse(cr, uid, ref('account_invoice_2_A_9'))

    # Sets the delay of the invoice to be just one day before the day in which the first follow-up level applies.
    new_due_date = (datetime.now() - timedelta(delay + 1)).strftime("%Y-%m-%d")
    invoice_obj.write({'date_due': new_due_date, 'payment_term': None})

    # Makes the follow-up level to send an email.
    self.pool.get('followup.level').write(cr, uid, context['first_followup_level'], {'send_email': True}, context=context)

-
  2.A.9. Checks if the state of the newly created invoice is in state 'draft'.
-
  !assert {model: account.invoice, id: account_invoice_2_A_9, string: 'State should be in state draft.'}:
    - state == 'draft'

-
  2.A.9. Makes sure that we do **not** want to skip the follow-up emails for this invoice.
-
  !python {model: account.invoice}: |
    invoice_obj = self.browse(cr, uid, ref('account_invoice_2_A_9'))
    invoice_obj.write({'followup_skip_email_sending': False})

-
  2.A.9. Validates invoice by clicking on the 'Validate' button.
-
  !workflow {model: account.invoice, action: invoice_open, ref: account_invoice_2_A_9}

-
  2.A.9. Checks if the state of the newly created invoice is in state 'open'.
-
  !assert {model: account.invoice, id: account_invoice_2_A_9, string: 'State should be in state open.'}:
    - state == 'open'

-
  2.A.9. Checks if the due days of the opened invoice is one plus the delay of the first follow-up level.
-
  !python {model: account.invoice}: |
    invoice_obj = self.browse(cr, uid, ref('account_invoice_2_A_9'))
    assert(invoice_obj.follow_up_date_due_days == (context['followup_level_delay'] + 1)), ("'Due days' should be {0}, but it is {1}".format(context['followup_level_delay'] - 1, invoice_obj.follow_up_date_due_days))

-
  2.A.9. Checks that 1) there is not follow-up level associated to the invoice,
                     2) its follow-up level has not been handled,
                     3) its handling date is empty.
-
  !python {model: account.invoice}: |
    invoice_obj = self.browse(cr, uid, ref('account_invoice_2_A_9'))
    assert(not invoice_obj.followup_level_id), ("'Follow-up Level' should be not set, but it is set to {0}.".format(invoice_obj.followup_level_id))
    assert(not invoice_obj.followup_level_handled), ("'Follow-up Level Handled' should be not set, but it is set to {0}.".format(invoice_obj.followup_level_handled))
    assert(not invoice_obj.followup_level_date), ("'Follow-up Handling Date' should be not set, but it is set to {0}.".format(invoice_obj.followup_level_date))

-
  2.A.9. Checks that there are not any emails yet.
-
  !python {model: mail.mail}: |
    mail_ids = self.search(cr, uid, [], context=context)
    assert(len(mail_ids) == 0), ("There should be no emails, but there are {0}.".format(len(mail_ids)))

-
  2.A.9. Executes the scheduler which updates the follow-up levels, and handles the invoice.
-
  !python {model: account.invoice}: |
    self.cron_update_invoice_followup_level(cr, uid, context)

    # Stores the date in which the scheduler was called (today).
    from datetime import datetime
    context['date_followup_levels_were_updated'] = datetime.now().strftime("%Y-%m-%d")
    
    # Handles the invoice ***a day after***.
    import anybox.testing.datetime
    from datetime import datetime, timedelta
    import time

    datetime.set_now(datetime.now() + timedelta(1))
    invoice_obj = self.pool.get('account.invoice').browse(cr, uid, ref('account_invoice_2_A_9'))
    invoice_obj.do_handle_followup()
    context['date_handling_was_done'] = datetime.now().strftime("%Y-%m-%d")
    datetime.real_now()

-
  2.A.9 Checks that the email is actually generated (test 2.A.9.a)
-
  !python {model: mail.mail}: |
    mail_ids = self.search(cr, uid, [], context=context)
    assert(len(mail_ids) == 1), ("There should be only one email, but {0} were generated.".format(len(mail_ids)))
    context['followup_mail_id'] = mail_ids[0]

-
  2.A.9. Checks that the email generated has type 'Email' (test 2.A.9.a.i)
-
  !python {model: mail.mail}: |
    mail_ids = self.search(cr, uid, [], context=context)[0]
    mail_obj = self.browse(cr, uid, mail_ids, context=context)
    assert(mail_obj.type == 'email'), ("The type of the email generated must be 'Email', and it is {0}.".format(mail_obj.type))

-
  2.A.9. Checks that the email generated is visible from the field 'Follow-up Mails' of the account.invoice (test 2.A.9.b)
-
  !python {model: account.invoice}: |
    invoice_obj = self.pool.get('account.invoice').browse(cr, uid, ref('account_invoice_2_A_9'))
    mail_id = self.pool.get('mail.mail').search(cr, uid, [], context=context)[0]
    assert(len(invoice_obj.followup_email_ids) == 1), ("Invoice must have one email associated to it.")
    assert(invoice_obj.followup_email_ids[-1].id == mail_id), ("The email associated to the invoice is not the generated one.")

-
  Checks that the email
    1) must be visible from the field "Follow-Up Mails" of the res.partner (test 2.A.9.c)
    2) must be visible from the field 'Follow-Up Mails' of the ancestors (test 2.A.9.f)
-
  !python {model: res.partner}: |
    from operator import attrgetter

    # We check that the email is visible from the res.partner.
    partner_obj = self.browse(cr, uid, ref('base.res_partner_address_4'))
    assert(context['followup_mail_id'] in map(attrgetter('id'), partner_obj.followup_mail_ids)), ("The generated email must be in the emails of the partner, but it is not.")

    # We check that it is not visible from the brother of the res.partner.
    partner_brother_obj = self.browse(cr, uid, ref('base.res_partner_address_3'))
    assert(context['followup_mail_id'] not in map(attrgetter('id'), partner_brother_obj.followup_mail_ids)), ("The generated email must not be in the emails of the partner's brother, but it is.")

    # We check that it is visible from its ancestor.
    partner_parent_obj = self.browse(cr, uid, ref('base.res_partner_2'))
    assert(context['followup_mail_id'] in map(attrgetter('id'), partner_parent_obj.followup_mail_ids)), ("The generated email must be in the emails of the partner's parent, but it is not.")

-
  2.A.9. Rollbacks.
-
  !python {model: account.invoice}: |
    cr.execute("ROLLBACK TO SAVEPOINT test;")
