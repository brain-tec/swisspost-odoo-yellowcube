# b-*- encoding: utf-8 -*-
##############################################################################
#
#    Copyright (c) 2017 brain-tec AG (http://www.braintec-group.com)
#    All Right Reserved
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################


from datetime import datetime
from dateutil.relativedelta import relativedelta
from openerp import netsvc
from openerp import pooler
from openerp.osv import osv, fields
from openerp import tools
from openerp.addons.pc_connect_master.utilities.db import create_db_index
from psycopg2 import OperationalError

class procurement_order(osv.osv):
    _inherit = 'procurement.order'

    _order = 'date_planned DESC'

    def create(self, cr, uid, vals, context=None):
        return super(procurement_order, self).create(cr, uid, vals, context)

    def write(self, cr, uid, ids, vals, context=None):
        return super(procurement_order, self).write(cr, uid, ids, vals, context)

    def init(self, cr):
        create_db_index(cr, 'procurement_order_move_id_state_index',
                        'procurement_order', 'move_id, state')

    def make_po(self, cr, uid, ids, context=None):
        """ Overridden so that for purchases coming from procurements
            generated by sale orders which require a dropshipping, the
            partner of the purchase is substituted by the shipping address
            of the sale.order.
        """
        if context is None:
            context = {}

        purchase_obj = self.pool.get('purchase.order')
        fiscal_position_obj = self.pool.get('account.fiscal.position')
        partner_obj = self.pool.get('res.partner')
        purchase_line_obj = self.pool.get('purchase.order.line')

        res = super(procurement_order, self).make_po(cr, uid, ids, context)

        for procurement_id, purchase_id in res.iteritems():
            proc = self.browse(cr, uid, procurement_id, context=context)

            # The first time we create a purchase from a procurement we keep
            # which purchase it was, because in the case of a future merge
            # of several purchases, we will loose the reference otherwise
            # since the ID of the new purchase result of the merge will be
            # stored in the purchase_id field.
            proc.write({'original_purchase_id': purchase_id})

            if proc.sale_id.stock_type_id and proc.sale_id.stock_type_id.dropship:

                # If the procurement came from a sale.order which required
                # a dropship, then the purchase must have as the partner
                # the shipping partner of the sale.order.
                purchase_partner_id = proc.sale_id.partner_shipping_id.id
                puchase_partner = partner_obj.browse(
                    cr, uid, purchase_partner_id, context=context)
                purchase_obj.write(cr, uid, purchase_id,
                                   {'partner_id': purchase_partner_id},
                                   context=context)

                # Also, the taxes in the purchase's lines have to be
                # mapped according to that partner, thus they have to be
                # overwritten.
                taxes_ids = proc.product_id.supplier_taxes_id
                taxes = fiscal_position_obj.map_tax(
                    cr, uid, puchase_partner.get_fiscal_position(),
                    taxes_ids)

                purchase_line_ids = purchase_line_obj.search(
                    cr, uid, [('order_id', '=', purchase_id),
                              ], context=context)
                purchase_line_obj.write(cr, uid, purchase_line_ids,
                                        {'taxes_id': [(6, 0, taxes)],
                                         }, context=context)

                # Sets the price on the purchase.order.line
                sale_line = proc.move_id.sale_line_id
                for purchase_line in purchase_line_obj.browse(
                        cr, uid, purchase_line_ids, context=context):

                    # Gets the price set on the sale.order.line
                    if sale_line.product_uom.id == purchase_line.product_uom.id:
                        price_unit = sale_line.price_unit
                    else:
                        # UOMs are different, thus we have to compute the price
                        # scaled taking account the different units of measure.
                        ratio = 1.0 / purchase_line.product_uom.factor
                        ratio = ratio * sale_line.product_uom.factor
                        price_unit = sale_line.price_unit * ratio

                    purchase_line_obj.write(cr, uid, purchase_line.id,
                                            {'price_unit': price_unit,
                                             }, context=context)

        return res

    def mrp_scheduler_for_sale_order_automation(self, cr, uid, automatic=False, use_new_cursor=False, context=None):
        """ Executes a slightly modified version of the MRP scheduler.

            It is overridden because the original scheduler interacts with the sale order automation in
            a way that, when going through all the procurement.orders, if it sees a stock move which is
            not in states 'done', 'assigned', or 'cancel', it attempts to assign the stock move. This
            has the side effect of interacting with the direct assignation, in which we allow a stock move
            to be sent partially: by splitting it into two: one with the part to be sent, and the
            other with the part that has to wait for more items to come --- we call this 'direct automation';
            however the assignation, or the attempt of assignation, of a stock move follows an all-or-nothing
            approach. Thus, if the original scheduler (method run_scheduler() of class procurement_order of
            file addons/procurement/schedulers.py) executes in between the step of the automation which creates
            the picking associated to a sale order, and the step in which this picking is assigned,
            it will cause the direct automation to fail.

            So, this modified version of the MRP scheduler actually is the same than the original one with
            JUST one (important) difference: the second step, called _procure_confirm() in the original
            scheduler, and now called _procure_confirm_sale_order_automation(), now filters those
            procurement.orders which relate to a stock.move which comes from a picking which comes from
            a sale order which is being automated; or which comes from a picking which relates to a sale order
            which was automated, but the picking is still not done (i.e. not yet delivered).
        """
        if use_new_cursor:
            use_new_cursor = cr.dbname
        self._procure_confirm_sale_order_automation(cr, uid, use_new_cursor=use_new_cursor, context=context)
        self._procure_orderpoint_confirm(cr, uid, automatic=automatic, use_new_cursor=use_new_cursor, context=context)

    def _procure_confirm_sale_order_automation(self, original_cr, uid, ids=None, use_new_cursor=False, context=None):
        """ Mostly taken _procure_orderpoint_confirm() in from addons/procurement/schedulers.py.

            See the comment on the caller mrp_scheduler_for_sale_order_automation to see the
            difference with the original implementation, and why we can not use it with the
            sale order automation.
        """
        if context is None:
            context = {}
        try:
            if use_new_cursor:
                cr = pooler.get_db(use_new_cursor).cursor()
            else:
                cr = original_cr
            wf_service = netsvc.LocalService("workflow")

            procurement_obj = self.pool.get('procurement.order')
            if not ids:
                ids = procurement_obj.search(cr, uid, [('state', '=', 'exception')], order="date_planned")
            for id in ids:
                wf_service.trg_validate(uid, 'procurement.order', id, 'button_restart', cr)
            if use_new_cursor:
                cr.commit()
            company = self.pool.get('res.users').browse(cr, uid, uid, context=context).company_id
            maxdate = (datetime.today() + relativedelta(days=company.schedule_range)).strftime(tools.DEFAULT_SERVER_DATE_FORMAT)
            prev_ids = []

            ids_to_skip = []
            while True:
                ids = procurement_obj.search(cr, uid, [('id', 'not in', ids_to_skip), ('state', '=', 'confirmed'), ('procure_method', '=', 'make_to_order'), ('date_planned', '<', maxdate)], limit=500, order='priority, date_planned', context=context)
                for proc in procurement_obj.browse(cr, uid, ids, context=context):
                    if self.skip_procure_confirmation_because_of_automation(cr, uid, proc.id, context=context):
                        ids_to_skip.append(proc.id)  # So that we don't iterate again over it.
                    else:
                        try:
                            wf_service.trg_validate(uid, 'procurement.order', proc.id, 'button_check', cr)
                            if use_new_cursor:
                                cr.commit()
                        except OperationalError:
                            if use_new_cursor:
                                cr.rollback()
                                continue
                            else:
                                raise
                if not ids or prev_ids == ids:
                    break
                else:
                    prev_ids = ids

            ids = []
            ids_to_skip = []
            prev_ids = []
            while True:
                ids = procurement_obj.search(cr, uid, [('id', 'not in', ids_to_skip), ('state', '=', 'confirmed'), ('procure_method', '=', 'make_to_stock'), ('date_planned', '<', maxdate)], limit=500)
                for proc in procurement_obj.browse(cr, uid, ids):
                    # The following if-else is the main change w.r.t. addons/procurement/schedulers.py.
                    if self.skip_procure_confirmation_because_of_automation(cr, uid, proc.id, context=context):
                        ids_to_skip.append(proc.id)  # So that we don't iterate again over it.
                    else:
                        try:
                            wf_service.trg_validate(uid, 'procurement.order', proc.id, 'button_check', cr)

                            if use_new_cursor:
                                cr.commit()
                        except OperationalError:
                            if use_new_cursor:
                                cr.rollback()
                                continue
                            else:
                                raise
                if not ids or prev_ids == ids:
                    break
                else:
                    prev_ids = ids

            if use_new_cursor:
                cr.commit()
        finally:
            if use_new_cursor:
                try:
                    cr.close()
                except Exception:
                    raise
        return {}

    def skip_procure_confirmation_because_of_automation(self, cr, uid, ids, context=None):
        """ Returns whether to skip a procurement.order. It must be skipped
            those procurements which relate to a stock.moves which comes
            from a picking which:
            1) come from a sale order which is being automated
               AND doesn't require a dropship; or
            2) come from a picking which relates to a sale order which was
               automated, but the picking is still not done (ie not yet
               delivered).
        """
        if context is None:
            context = {}
        if type(ids) is not list:
            ids = [ids]

        procurement = self.browse(cr, uid, ids[0], context=context)

        skip_procurement = False

        picking = procurement.move_id.picking_id
        sale_order = picking and picking.sale_id or False
        if sale_order and sale_order.automate_sale_order_process:
            if not sale_order.is_dropship():
                if not sale_order.automation_finished:
                    skip_procurement = True
                elif picking.state not in ('done', 'cancel'):
                    skip_procurement = True

        return skip_procurement

    _columns = {
        'sale_id': fields.many2one(
            'sale.order', 'Originating Sale Order',
            help='Sale order which originated the procurement order.'),

        'original_purchase_id': fields.many2one(
            'purchase.order', 'Purchase Order (Original)', select=True,
            help='The purchase order that was generated by this procurement.'
                 'Notice that this may be different than the purchase which '
                 'ends up being related to the procurement in the case '
                 'several were merged into one.'),
    }

# vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4:
